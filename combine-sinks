#!/bin/bash

# Script: combine-sinks
# Description: Manages PulseAudio/PipeWire sinks by creating a combined sink for multiple audio outputs.
# Usage: /usr/libexec/combine-sinks

# Set the necessary environment variables for PipeWire (or PulseAudio)
export PULSE_RUNTIME_PATH="/run/user/1000/pulse/"
export XDG_RUNTIME_DIR="/run/user/1000/"

# Set error handling
set -euo pipefail

# Constants
OVOS_USER="$(getent passwd 1000 | cut -d: -f1)"  # Get the username of the first non-system user

# Function to detect the active sound server (PipeWire, PulseAudio, or ALSA)
# Returns the sound server type as a string
detect_sound_server() {
    # Check if PipeWire is installed
    if command -v pipewire > /dev/null; then
        echo "pipewire"
    # Check if PulseAudio is installed
    elif command -v pulseaudio > /dev/null; then
        echo "pulse"
    # Check if ALSA is available
    elif command -v aplay > /dev/null && command -v amixer > /dev/null; then
        echo "alsa"
    else
        echo "No sound server detected"
        exit 1
    fi
}

# Log function to write to a log file
# Args:
#   $1: Message to log
log_message() {
    echo "$1"
    echo "$(date) - $1" >> /tmp/autosink.log
}

# Function to handle errors
error_handler() {
    local line_no=$1
    local error_code=$2
    log_message "Error (code: ${error_code}) occurred on line ${line_no}"
    exit ${error_code}
}

trap 'error_handler ${LINENO} $?' ERR

# Detect sound server
SOUND_SERVER=$(detect_sound_server)

# Function to create the combined ALSA virtual device
create_combined_alsa_device() {
    local combined_device_name="auto_combined"

    # Detect all available ALSA devices
    local devices=$(aplay -l | awk '/card/ {print $2}' | tr -d ':' | tr '\n' ',' | sed 's/,$//')
    if [ -z "$devices" ]; then
        log_message "No ALSA devices found."
        exit 1
    fi

    # Create a virtual combined ALSA device by modifying the asound.conf file
    local card_entries=""
    local card_index=0

    for device in $(echo "$devices" | tr ',' '\n'); do
        # We create a slave entry for each ALSA device found
        card_entries+="slaves.${card_index}.pcm \"hw:${device}\"\n"
        card_entries+="bindings.${card_index} 0\n"  # Map the channels
        ((card_index++))
    done

    cat <<EOL > "/home/$OVOS_USER/.asoundrc"
pcm.!default {
    type multi
    ${card_entries}
}

ctl.!default {
    type hw
    card 0
}
EOL
}


# Check if ALSA is in use
if [ "$SOUND_SERVER" == "alsa" ]; then
    create_combined_alsa_device

    #log_message "Playing test sound through combined ALSA device..."
    #aplay -D "default" /usr/share/sounds/alsa/Front_Center.wav
    exit 0
fi

if [ "$EUID" -eq 0 ]; then
    log_message "Running as root"
else
    log_message "Running as user"
fi

# Function to check and return a list of sinks
get_sinks() {
    if [ "$SOUND_SERVER" == "pulse" ]; then
        pactl list short sinks | awk '{print $2}' | grep -v 'auto_combined' | grep -v 'auto_null' | tr '\n' ',' | sed 's/,$//'
    elif [ "$SOUND_SERVER" == "pipewire" ]; then
        echo "TODO"
    fi
}

# Check for "auto_null" sink
wait_for_auto_null() {
    if [ "$SOUND_SERVER" == "pulse" ] && pactl list short sinks | grep -q "auto_null"; then
        log_message "auto_null sink exists, still booting? Sleeping for 3 seconds..."
        sleep 3
    elif [ "$SOUND_SERVER" == "pipewire" ]; then
        echo "TODO"
        sleep 3
    fi
}

# Retry getting sinks if none are found
retry_get_sinks() {
    local retries=5
    local sinks=""
    while [ -z "$sinks" ] && [ "$retries" -gt 0 ]; do
        log_message "Retrying to find sinks... ($retries retries left)"
        sleep 1
        retries=$((retries - 1))
        sinks=$(get_sinks)
    done
    echo "$sinks"
}

# Main logic to detect the sound server and handle sinks
log_message "Setting up audio output as combined sinks"
wait_for_auto_null

# Log the current sinks before any action
if [ "$SOUND_SERVER" == "pulse" ]; then
  log_message "Sinks before action: $(pactl list short sinks)"
elif [ "$SOUND_SERVER" == "pipewire" ]; then
  log_message "Sinks before action: $(wpctl status)"
fi

# Get all sinks, excluding 'auto_combined' and 'auto_null'
# NOTE: sometimes errors here if early in boot process, its fine as the .service retries on failure
SINKS=$(retry_get_sinks)
NUM_SINKS=$(echo "$SINKS" | tr ',' '\n' | wc -l)

# Check if auto_combined is present
if [ "$SOUND_SERVER" == "pulse" ]; then
  if pactl list short sinks | grep -q "auto_combined"; then
      log_message "auto_combined sink exists"
  else
      log_message "auto_combined sink missing"
  fi
elif [ "$SOUND_SERVER" == "pipewire" ]; then
  if wpctl status | grep -q "auto_combined"; then
      log_message "auto_combined sink exists"
  else
      log_message "auto_combined sink missing"
  fi
fi

log_message "Total sinks: $NUM_SINKS"

# Create a combined sink if there is more than one sink
if [ "$NUM_SINKS" -gt 1 ]; then
    if [ "$SOUND_SERVER" == "pulse" ]; then
        pactl unload-module module-combine-sink 2>/dev/null || true
        if ! MODULE_ID=$(pactl load-module module-combine-sink slaves="$SINKS" sink_name=auto_combined); then
            log_message "Failed to create combined sink"
            exit 1
        fi
        if pactl list short sinks | grep -q "auto_combined"; then
            pactl set-default-sink auto_combined
            log_message "Combined sink created with outputs: $SINKS (module ID: $MODULE_ID)"
        else
            log_message "Combined sink creation failed"
            exit 1
        fi
    elif [ "$SOUND_SERVER" == "pipewire" ]; then
        echo "TODO"
    fi
else
    log_message "No sinks found to combine"
fi

# Log the current sinks after action
if [ "$SOUND_SERVER" == "pulse" ]; then
    log_message "Sinks after action: $(pactl list short sinks)"
elif [ "$SOUND_SERVER" == "pipewire" ]; then
    log_message "Sinks after action: $(wpctl status)"
fi
